#	파동방정식을 위에서 배운 지식들을 활용하여 최대한 가속화하라
* 코드  
![image](https://user-images.githubusercontent.com/83944915/118294826-19b2fa80-b516-11eb-8c55-d16fffa885f5.png)
![image](https://user-images.githubusercontent.com/83944915/118294868-25062600-b516-11eb-8cc2-5be359b41d7a.png)
![image](https://user-images.githubusercontent.com/83944915/118294886-2a637080-b516-11eb-8417-6b23332d26df.png)
*	고찰

> 5주차 실험으로 CUDA C++을 이용한 가속화 어플리케이션에 대해 배우고 실습했다. 기존의 C++ 코드로 계산을 하면 CPU만으로 계산이 되는 반면 CUDA를 통해 GPU를 이용한 가속화 컴퓨팅을 하면 병렬연산을 통해 더욱 빠른 계산 속도를 얻을 수 있다. CUDA를 이용한 실습 후 과제로 CPU만 이용하는 Wave equation C++코드를 GPU 병렬연산으로 가속시키는 CUDA 코드로 변형시키는 것을 수행했다.

> Wave equation을 가속화할 때 사용한 주요 요소는 크게 다섯가지(__global__선언, 그리드 폭 반복, GPU 메모리 할당 및 해제, 커널 구동 및 동기화, CUDA코드 컴파일 및 실행)로 나눌 수 있다. 첫 번째로 __global__선언이다. 이것은 GPU 함수로 바꿔주는 것으로 이해할 수 있고 반드시 void 타입으로 리턴해야한다. 아래의 식을 보면 변수 U앞에 *이 붙어 있는 것을 볼 수 있는데 이는 U가 배열이기 때문에 포인터를 붙여 준 것이다. 두 번째로, 그리드 폭 반복이다. 스레드, 블록 인덱스 그리고 블록, 그리드 디멘션의 값을 이용해 idx와 stride를 선언하고 idx를 시작점으로 stride를 뛰어넘는 폭으로 사용하여 그리드보다 큰 데이터 집합에 대해 다중 병렬연산을 할 수 있다. 세 번째로, GPU 메모리 할당 및 해제이다. CPU에서 메모리 할당을 할 때 사용하는 함수인 malloc은 GPU 연산에서 사용을 할 수 없기 때문에 GPU에서 메모리 할당을 시켜줄 수 있는 cudaMallocManaged 명령어를 사용해야한다. 또한, 메모리 할당을 해제할 때 역시 free 명령어 대신 cudaFree 명령어를 사용해야 한다. 네 번째로, 커널 구동 및 동기화이다. __global__ 선언을 한 함수를 사용하기 위해 특정 형태를 맞추어 구동해야 하고 동기화를 해주지 않는다면 GPU 연산을 무시하고 CPU 연산만으로 실행이 종료되기 때문에 cudaDeviceSynchronize를 통한 동기화가 필수적이다. 마지막으로, CUDA코드 컴파일 및 실행이다. !nvcc 명령어를 이용해 해당 CUDA 코드를 컴파일 및 실행 할 수 있다.

> Wave equation 코드 결과 테스트를 하던 중 여러 시행착오를 겪었다. 그중 __global__선언 함수가 실행되지 않은 결과를 여러 번 얻은 것이 기억에 남는다. 이 경우 cudaDeviceSynchronize 명령어를 1개만 사용했었고 이 명령어의 위치지정을 다르게 할 때마다 하나의 함수만 적용이 되거나 아예 적용이 되지 않는 결과를 확인할 수 있었다. 코드를 보고 __global__함수를 출력할 때 동기화를 시켜주지 않아 문제가 된 것을 확인하여 cudaDeviceSynchronize 명령어를 2개 사용하였고 위치 조정을 제대로 해주어 C++ 구문의 wave equation과 같은 결과를 얻었다. 이를 통해 동기화의 중요성을 다시 한번 깨닫게 되었다.

> Wave equation 코드를 최대한 가속화하기 위해 앞에 선언한 함수를 __global__로 선언하였고 함수 내부의 for문을 가속화하기 위해 grid_stride loop를 사용했다. 해당 방법을 이용해 가속화에 성공하였고 C++ 구문의 Wave equation 결과와 정확히 일치하는 것을 확인했다. 더 가속화할 방법이 없을까 고민을 하던 중, U[i] 배열을 출력해주는 반복문을 grid_stride loop로 사용하면 계산속도를 줄일 수 있을 것이란 생각이 들었다. 이를 위해 __global__ void printI(float *U, int N)을 선언하여 사용해 보았지만 실행할 때마다 출력 값이 뒤죽박죽 섞여 있는 결과를 확인할 수 있었다. 이를 통해 GPU를 통한 병렬 연산의 경우 순차적인 출력을 보장하지 않는다는 사실을 알게 되었다. 또한 순차적인 출력을 위해 CPU에서 for문을 사용하여 출력하며 GPU 함수로도 block을 1개 thread를 N개를 잡는 등의 방법으로 순차 출력할 수 있으나 시간적 이득을 볼 수 없기 때문에 순차적인 출력이 필요한 구문의 경우 병렬연산을 하지 않는다. 따라서, 위의 Wave equation같은 경우 배열 계산에 GPU 병렬연산을 통한 가속화를 하는 것이 최선의 가속방법으로 보인다.

> 지금까지 CUDA를 이용하여 C++ 구문의 wave equation을 병렬가속화 하는 것을 코딩해보았다. 이번 실험을 통해 순차적인 출력이 필요한 구문의 경우 병렬 계산이 의미가 없기 때문에 CPU로 계산한다는 점, 병렬 계산이 필요한 함수를 GPU로 가속화했을 때 계산시간의 이점을 얻을 수 있다는 점 그리고 GPU함수를 이용할 때 커널 구동 동기화의 중요성을 알게 되었다. 또한, 위의 코드를 통해 CUDA를 이용하면 GPU 병렬 계산을 사용해 wave equation을 가속화하여 시간적 이점을 가질 수 있다는 결과를 얻게 되었다.
